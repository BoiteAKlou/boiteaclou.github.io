<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-06-25T22:22:40+02:00</updated><id>http://localhost:4000/</id><title type="html">Computer Security for Beginners</title><subtitle>Computer security oriented blog held by a french student in IT and Networks. This blog aims at teaching the fundamentals of Cyber Security to beginners through CTF write-ups and didactic articles.</subtitle><author><name>BoiteAKlou</name></author><entry><title type="html">A very fine cipher: Warmup - AngstromCTF</title><link href="http://localhost:4000/crypto/2018/06/24/A-very-fine-cipher-Warmup-AngstromCTF.html" rel="alternate" type="text/html" title="A very fine cipher: Warmup - AngstromCTF" /><published>2018-06-24T23:00:00+02:00</published><updated>2018-06-24T23:00:00+02:00</updated><id>http://localhost:4000/crypto/2018/06/24/A-very-fine-cipher-Warmup-AngstromCTF</id><content type="html" xml:base="http://localhost:4000/crypto/2018/06/24/A-very-fine-cipher-Warmup-AngstromCTF.html">&lt;p&gt;Here comes the first Cryptographic challenge! We’ll start with an easy one but nonetheless useful. We will establish the mathematical foundations needed for understanding more complicated codes such as RSA…
 &lt;!--excerpt--&gt;&lt;/p&gt;

&lt;h2 id=&quot;challenge-description&quot;&gt;Challenge description&lt;/h2&gt;

&lt;p&gt;The challenge statement is very explicit:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Just a quick warm-up cipher for everyone. Honestly, I think it’s &lt;strong&gt;a fine&lt;/strong&gt; cipher.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;myjd{ij_fkwizq}&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The sentence in bold has to be decoded in order to get the flag and to validate the challenge.&lt;/p&gt;

&lt;p&gt;If you’re already familiar with affine cipher or just want to read the challenge’s write-up, you can jump straight to the &lt;em&gt;Breaking the code&lt;/em&gt; section.&lt;/p&gt;

&lt;h2 id=&quot;information-gathering&quot;&gt;Information gathering&lt;/h2&gt;

&lt;p&gt;The information gathering part of the analysis is probably the most important as it can be really time-saving. That’s why we’ll try to gather as much information as possible.&lt;/p&gt;

&lt;p&gt;The first thing that jumps out is the format of the ciphered text. Each CTF contest has its own flag format so participants know when they have solved the challenge.
In the context of AngstromCTF, each flag respects the following convention: &lt;strong&gt;actf{…}&lt;/strong&gt;, which is suspiciously close to our ciphered text.&lt;/p&gt;

&lt;p&gt;Cryptanalysis can be greatly simplified when the plain text language is known. Since AngstromCTF is an international event, the language used is probably english.&lt;/p&gt;

&lt;p&gt;The most useful information turns out to be the discrete hint given in the challenge description. Indeed, “a fine” is in bold for a reason. It’s actually a wordplay with &lt;strong&gt;affine cipher&lt;/strong&gt;… These funny organizers decided to save us a lot of time!&lt;/p&gt;

&lt;h2 id=&quot;affine-cipher&quot;&gt;Affine cipher&lt;/h2&gt;

&lt;p&gt;The affine cipher is a type of &lt;strong&gt;monoalphabetic substitution cipher&lt;/strong&gt; based on a simple mathematical function. It has only been used for its educational purposes due to its weaknesses. We’ll study the functionning of this cipher and how to break it in order to decode our mistery sentence.&lt;/p&gt;

&lt;h3 id=&quot;monoalphabetic-substitution-cipher&quot;&gt;Monoalphabetic substitution cipher&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;substitution cipher&lt;/strong&gt; is a method of encrypting which replaces each letter of the plain text by a letter of the ciphered text. In most of the case, the replacement unit is a single letter but it could also be a group of three letters. The &lt;strong&gt;plain text&lt;/strong&gt; and the &lt;strong&gt;ciphered&lt;/strong&gt; one will have &lt;strong&gt;the exact same length&lt;/strong&gt; when using a substitution cipher.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Monoalphabetic&lt;/strong&gt; means that the same alphabet is used for encrypting the whole message. On the contrary, &lt;strong&gt;Polyalphabetic&lt;/strong&gt; substitution ciphers will use multiple alphabets for encrypting the same message. They are generally much &lt;strong&gt;stronger&lt;/strong&gt; than &lt;strong&gt;Monoalphabetic ciphers&lt;/strong&gt; because each letter of the plaintext is usually mapped to multiple different letters in the ciphered text.&lt;/p&gt;

&lt;h3 id=&quot;encryption&quot;&gt;Encryption&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;The first step of the encryption process consists in assigning an integer in the range 0 to \(m-1\) to each letter, where &lt;strong&gt;m is the size of the alphabet&lt;/strong&gt; (usually 26).&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;d&lt;/td&gt;
      &lt;td&gt;e&lt;/td&gt;
      &lt;td&gt;f&lt;/td&gt;
      &lt;td&gt;g&lt;/td&gt;
      &lt;td&gt;h&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;x&lt;/td&gt;
      &lt;td&gt;y&lt;/td&gt;
      &lt;td&gt;z&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Then we have to define a pair of integers \((a,b)\) which will represent &lt;strong&gt;the key&lt;/strong&gt;. In order to be able to decipher the message, &lt;strong&gt;a must be coprime with m&lt;/strong&gt;. If it’s not the case, the same integer will be associated with more than one letter in our table.
This gives the following list of possibilities for \(a\): 1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the example, we will choose the couple \((a = 5, b = 8)\) as the key.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Now that each letter is associated with an integer and that we have defined the key, we are ready to encrypt the message. In order to do this, we simply have to apply the mathematical formula that defines the affine cipher, with \(x\) being the &lt;strong&gt;integer associated with the letter&lt;/strong&gt; we want to encrypt:&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E(x) = (ax + b)\mod{m}&lt;/script&gt;

&lt;p&gt;To give you an example, let’s say we want to encrypt the following sentence using the key defined above:&lt;/p&gt;

&lt;p&gt;CRYPTOISLOVE&lt;/p&gt;

&lt;p&gt;We will get the integers associated with each letter as the following:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;P&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;S&lt;/td&gt;
      &lt;td&gt;L&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Then, we will apply the encryption function for each letter resulting in the following:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;Detail of the first column:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{eqnarray}
E(2) &amp;=&amp; 2\times 5 + 8\mod{26}\\
E(2) &amp;=&amp; 18
\end{eqnarray} %]]&gt;&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And convert back the obtained integers into letters to get the ciphered message:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S&lt;/td&gt;
      &lt;td&gt;P&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;Z&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;W&lt;/td&gt;
      &lt;td&gt;U&lt;/td&gt;
      &lt;td&gt;L&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;J&lt;/td&gt;
      &lt;td&gt;C&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The encryption is done!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;NOTE: We can notice that some popular shift ciphers such as &lt;strong&gt;Caesar cipher&lt;/strong&gt; or &lt;strong&gt;ROT13&lt;/strong&gt; are basically affine ciphers with the &lt;strong&gt;a coefficient set to 1&lt;/strong&gt; and the &lt;strong&gt;b coefficient representing the shift&lt;/strong&gt;. We can describe these ciphers as affine ciphers using the following keys: &lt;strong&gt;Caesar(1,3)&lt;/strong&gt; &amp;amp; &lt;strong&gt;ROT13(1,13)&lt;/strong&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;decryption&quot;&gt;Decryption&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;The first step of the decryption process consists in replacing each letter of the ciphered text with the corresponding integer.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;S&lt;/td&gt;
      &lt;td&gt;P&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;Z&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;W&lt;/td&gt;
      &lt;td&gt;U&lt;/td&gt;
      &lt;td&gt;L&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;J&lt;/td&gt;
      &lt;td&gt;C&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Then we have to find the &lt;strong&gt;modular multiplicative inverse&lt;/strong&gt; of \(a\). There are different ways to do it which won’t be detailed here. If you’re interested in knowing how to compute it, you should have a look at &lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm&quot;&gt;Extended Euclidean algorithm&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Euler%27s_theorem&quot;&gt;Euler’s theorem&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In our previous example, the &lt;strong&gt;modular multiplicative inverse&lt;/strong&gt; of \(a\) is 21. We will call it \(a’\).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Now can apply the following decryption function to each integer of the table and convert the result back into letter to get the deciphered message.&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;D(x) = a'(x-b)\mod{m}&lt;/script&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;After converting the integers back into letters we will recover the original plain text.&lt;/p&gt;

&lt;h2 id=&quot;breaking-the-code&quot;&gt;Breaking the code&lt;/h2&gt;

&lt;p&gt;Now that we have a clearer idea of the mechanisms involved by affine cipher, we can eventually spot the weaknesses. In order to decode the ciphered sentence, we have to either find the key or find another way to recover the plain text.&lt;/p&gt;

&lt;h3 id=&quot;kerckhoffs-principle&quot;&gt;Kerckhoffs’ Principle&lt;/h3&gt;

&lt;p&gt;Kerckhoffs’ Principle is a basic design principle of modern cryptography formulated by Auguste Kerckhoffs in 1883.&lt;/p&gt;

&lt;p&gt;It goes as follows:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A cryptographic system should be secure even if everything about the system, except the key, is public knowledge.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The affine cipher often uses an alphabet of 26 letters including 12 numbers which are coprime with 26. This gives us a total of \(12 \times 26 = 312\) possible keys.&lt;/p&gt;

&lt;p&gt;This is something we can easily bruteforce so this cipher is considered as highly insecure in the light of Kerckhoffs’ Principle.&lt;/p&gt;

&lt;h3 id=&quot;frequency-analysis&quot;&gt;Frequency Analysis&lt;/h3&gt;

&lt;p&gt;Frequency Analysis is a very popular method of cryptanalysis. It consists in studying the frequency of letters in a ciphertext.
For example, if the most occurent letter in a ciphered text is “Z”, you can suppose that “Z” replaces the most common letter of the source language (which is “E” in the English language).&lt;/p&gt;

&lt;p&gt;Every monoalphabetic substitution cipher is vulnerable to this method of cryptanalysis. However, it requires a long ciphered text for the frequency analysis to be relevant. In the context of this challenge, we only have a single sentence, which is clearly not sufficient. Let’s save this method for another challenge… :wink:&lt;/p&gt;

&lt;h3 id=&quot;not-even-funny&quot;&gt;Not even funny&lt;/h3&gt;

&lt;p&gt;We said earlier that the key was easily crackable thanks to a fine &lt;strong&gt;bruteforce algorithm&lt;/strong&gt;. This is the dumb but efficient way to achieve the challenge.
Feel free to write a small &lt;strong&gt;script&lt;/strong&gt; which will &lt;strong&gt;test the 312 possible keys&lt;/strong&gt; and decode the message. It’s always good to practice our scripting skills.&lt;/p&gt;

&lt;p&gt;However, this may not be necessary to write a script for solving this challenge, as we will see in the next part.&lt;/p&gt;

&lt;h3 id=&quot;smart-way---known-plain-attack&quot;&gt;Smart way - Known plain attack&lt;/h3&gt;

&lt;p&gt;This is where the &lt;em&gt;information gathering&lt;/em&gt; part becomes interesting. We’ve noticed the suspiceous beginning of the ciphered text which is very close to the flag format of this CTF.&lt;/p&gt;

&lt;p&gt;It is quite likely that &lt;strong&gt;actf{…}&lt;/strong&gt; becomes &lt;strong&gt;myjd{…}&lt;/strong&gt; when encrypted. If we find the key that gives such ciphered text, we will be able to decrypt the rest of the flag.&lt;/p&gt;

&lt;p&gt;This is called a &lt;strong&gt;known plain attack&lt;/strong&gt;. We know a part of the plain text and it’s corresponding ciphered text. From that, we can try guess the key and be able discover the whole message. This type of attack is not always possible but it works perfectly in our case.&lt;/p&gt;

&lt;h4 id=&quot;demonstration&quot;&gt;Demonstration&lt;/h4&gt;

&lt;p&gt;Once again, we assign an integer to each letter of the plain and the ciphered text:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;t&lt;/td&gt;
      &lt;td&gt;f&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;m&lt;/td&gt;
      &lt;td&gt;y&lt;/td&gt;
      &lt;td&gt;j&lt;/td&gt;
      &lt;td&gt;d&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;According to our hypothesis that the beginning of the ciphered text corresponds to &lt;strong&gt;actf{&lt;/strong&gt;, we have:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{eqnarray}
	E(0) &amp;=&amp; 12\\
	E(2) &amp;=&amp; 24\\
	E(19) &amp;=&amp; 9\\
	E(5) &amp;=&amp; 3\\
\end{eqnarray} %]]&gt;&lt;/script&gt;

&lt;p&gt;The first equation means that when we encrypt the letter number 0, it gives the letter number 12.
We won’t need more than the first two equations in order to find the key.&lt;/p&gt;

&lt;p&gt;This gives the following system:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\left\{
\begin{array}{r c l}
0a + b &amp;\equiv&amp; \boxed{12}\mod{26}\\
2a + b &amp;\equiv&amp; 24\mod{26}\\
\end{array}
\right. %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{array}{r c l}
\Leftrightarrow 2a &amp;\equiv&amp; 12\mod{26}\\
\Leftrightarrow 2a &amp;\equiv&amp; 38\mod{26}\\
\Leftrightarrow a &amp;\equiv&amp; \boxed{19}\mod{26}\\
\end{array} %]]&gt;&lt;/script&gt;

&lt;p&gt;Here is the key!&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;key (19,12)&lt;/script&gt;

&lt;h4 id=&quot;decryption-1&quot;&gt;Decryption&lt;/h4&gt;

&lt;p&gt;Using the key and the previously explained process of decryption, we are able to recover the plain text, which was indeed a magnificent flag!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;actf{it_begins}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;That’s it for this challenge but don’t worry, it was only the warm-up! :blush: Do not hesitate to leave a comment or to contact me for any question or inquiry.&lt;/p&gt;

&lt;p&gt;BoiteAKlou :hammer:&lt;/p&gt;</content><author><name>BoiteAKlou</name></author><summary type="html">Here comes the first Cryptographic challenge! We’ll start with an easy one but nonetheless useful. We will establish the mathematical foundations needed for understanding more complicated codes such as RSA…</summary></entry><entry><title type="html">Introduction to Buffer Overflows: CookieJar - AngstromCTF</title><link href="http://localhost:4000/pwning/2018/06/05/Introduction-to-Buffer-Overflows-CookieJar-AngstromCTF.html" rel="alternate" type="text/html" title="Introduction to Buffer Overflows: CookieJar - AngstromCTF" /><published>2018-06-05T08:35:00+02:00</published><updated>2018-06-05T08:35:00+02:00</updated><id>http://localhost:4000/pwning/2018/06/05/Introduction-to-Buffer-Overflows-CookieJar-AngstromCTF</id><content type="html" xml:base="http://localhost:4000/pwning/2018/06/05/Introduction-to-Buffer-Overflows-CookieJar-AngstromCTF.html">&lt;p&gt;For my first article on this blog, I’ll present you my write-up of “CookieJar” from the AngstromCTF. This challenge was accessible and very straight-forward, which constitutes the prefect opportunity to introduce &lt;strong&gt;Buffer Overflows&lt;/strong&gt;…
 &lt;!--excerpt--&gt;&lt;/p&gt;

&lt;h2 id=&quot;pre-requisites&quot;&gt;Pre-requisites&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;A very basic understanding of &lt;strong&gt;x86 or x64 architectures&lt;/strong&gt; will help you to grasp the concept of buffer overflow.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;challenge-description&quot;&gt;Challenge description&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/2018-06-05/challenge.png&quot; alt=&quot;challenge statement&quot; title=&quot;Statement&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We have &lt;a href=&quot;/assets/2018-06-05/cookiePublic.c&quot;&gt;a binary&lt;/a&gt; and the corresponding &lt;a href=&quot;/assets/2018-06-05/cookiePublic64&quot;&gt;source code&lt;/a&gt; given for this challenge. The objective is to find a way to exploit this binary locally and to re-use the same exploit on the remote server in order to get the flag.&lt;/p&gt;

&lt;p&gt;The first thing we should do in this case is to analyze the program and its source code.&lt;/p&gt;

&lt;h2 id=&quot;program-analysis&quot;&gt;Program analysis&lt;/h2&gt;
&lt;h3 id=&quot;lets-run-it-&quot;&gt;Let’s run it !&lt;/h3&gt;

&lt;p&gt;Here is a standard execution:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boiteaklou@csb:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./cookiePublic64
Welcome to the Cookie Jar program!

In order to get the flag, you will need to have 100 cookies!

So, how many cookies are there &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the cookie jar:
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 100
Sorry, you only had 0 cookies, try again!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The program asks for an number of cookies in the jar but no matter what we submit, it seems that we are stuck with 0 cookies.&lt;/p&gt;

&lt;p&gt;Alright, now let’s dive into the code!&lt;/p&gt;

&lt;h3 id=&quot;source-code-dissection&quot;&gt;Source code dissection&lt;/h3&gt;

&lt;p&gt;The code is pretty simple so the vulnerability should jump out.&lt;/p&gt;

&lt;p&gt;Don’t pay attention to the first part of the main function, it only sets the execution rights of the program.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;gid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getegid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;setresgid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here are the noticeable parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A variable named &lt;strong&gt;numCookies&lt;/strong&gt; is declared and initialized with 0.
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numCookies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;A buffer is declared with a size of 64 characters for storing the user input.
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;A simple check is done on &lt;strong&gt;numCookies&lt;/strong&gt; and displays the &lt;strong&gt;flag&lt;/strong&gt; if numCookies&amp;gt;=100.
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numCookies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Congrats, you have %d cookies!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numCookies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Here's your flag: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FLAG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Sorry, you only had %d cookies, try again!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numCookies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of this seems pretty legit but there’s no way to increment this variable… We’re probably missing something.&lt;/p&gt;

&lt;h2 id=&quot;vulnerabilty-explanation&quot;&gt;Vulnerabilty explanation&lt;/h2&gt;

&lt;p&gt;I’ll give you a hint:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gets(buffer);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;At this moment, you must be like “Yeah… OK… tell me more” and it’s normal if you’ve never encountered this kind of vulnerability.&lt;/p&gt;

&lt;p&gt;However, this is probably one of the most common exploit and it’s called &lt;strong&gt;buffer overflow&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;what-is-a-buffer-overflow&quot;&gt;What is a buffer overflow?&lt;/h3&gt;

&lt;p&gt;When a variable is declared, space is allocated on the stack according to the size of our variable.&lt;/p&gt;

&lt;p&gt;Let’s take the example of the buffer from the challenge:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After this instruction, &lt;strong&gt;64 bytes are allocated on the stack&lt;/strong&gt; in order to store the value contained in the buffer (A char is coded on a single byte in C).&lt;/p&gt;

&lt;p&gt;In compiled languages such as C, the memory is allocated at the compilation time and this process is sequential. It means that the next variable found in the code will be located above the previous one on the stack.&lt;/p&gt;

&lt;p&gt;Also keep in mind that &lt;strong&gt;the highest addresses are located at the bottom of the stack&lt;/strong&gt; in our architecture.&lt;/p&gt;

&lt;p&gt;In the source code of the challenge, the very interesting variable &lt;strong&gt;numCookies&lt;/strong&gt; is declared just before the buffer. In other words, &lt;strong&gt;the buffer will be stored right above numCookies on the stack.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numCookies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s represent the hypotetical state of the stack:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-06-05/stack-draw.png&quot; alt=&quot;State of the stack&quot; title=&quot;State of the stack&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, you should be able to start guessing the impact of such vulnerability.&lt;/p&gt;

&lt;p&gt;Indeed, we have 64 bytes of memory allocated to our buffer, but what happens if we try to write more than 64 bytes?&lt;/p&gt;

&lt;p&gt;Any idea? … It simply &lt;strong&gt;overwrites the values&lt;/strong&gt; stored in variables that are located below the buffer on the stack.&lt;/p&gt;

&lt;h3 id=&quot;what-does-it-involve&quot;&gt;What does it involve?&lt;/h3&gt;

&lt;p&gt;Overwriting variables in the stack can result in random effects if the attacker doesn’t control the impacted variables.&lt;/p&gt;

&lt;p&gt;However, if the stack is perfectly controlled, the attack can occur a &lt;strong&gt;program crash&lt;/strong&gt; or &lt;strong&gt;provide full-rights on the machine&lt;/strong&gt; to the attacker by executing a shellcode.&lt;/p&gt;

&lt;p&gt;Buffer overflows only act as &lt;strong&gt;vectors of attack&lt;/strong&gt;, they represent a way of gaining access or executing code on the machine but they often don’t symbolize the attack in its entirety. Once the access is granted on the machine, the funny things can start…&lt;/p&gt;

&lt;p&gt;We will see more advanced exploits based on buffer overflows in future articles, don’t worry about that :wink:.&lt;/p&gt;

&lt;h2 id=&quot;detection-of-the-vulnerable-code&quot;&gt;Detection of the vulnerable code&lt;/h2&gt;

&lt;p&gt;Alright, this vulnerability seems really powerful but is there a way to prevent it? How do we identify the vulnerable piece of code?&lt;/p&gt;

&lt;p&gt;In our case, the vulnerability is simple to exploit because of the lack of user input control. The following part of the code is vulnerable because the developper didn’t verify the length of the user input.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;gets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A simple &lt;code class=&quot;highlighter-rouge&quot;&gt;man gets&lt;/code&gt; warns us about the usage of this function and its level of risk.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Never use gets().  Because it is impossible to tell without knowing the data in advance how many characters gets() will read,  and  because gets()  will continue to store characters past the end of the buffer, it is extremely dangerous to use.  It has been used to break computer security. Use fgets() instead.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here is what a careful developer should have written:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;OR&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you were to retain one thing from this article, as a developer, it would be this: &lt;strong&gt;NEVER TRUST USER INPUT&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;exploit&quot;&gt;Exploit&lt;/h2&gt;

&lt;p&gt;Now that we have identified the &lt;strong&gt;vector of attack&lt;/strong&gt; and the piece of &lt;strong&gt;vulnerable code&lt;/strong&gt;, we can write the exploit!&lt;/p&gt;

&lt;p&gt;Our objective is to bypass this “if statement”: &lt;code class=&quot;highlighter-rouge&quot;&gt;if (numCookies &amp;gt;= 100){&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In order to do that, we have to set &lt;strong&gt;numCookies&lt;/strong&gt; to &lt;strong&gt;100 or greater&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Let’s get our hands dirty!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You get it, we have to submit more than 64 characters to the program.&lt;/p&gt;

&lt;p&gt;There are 2 methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You can enter the 64 characters manually when the program asks for a number of cookies.&lt;/li&gt;
  &lt;li&gt;Or you can &lt;strong&gt;use a scripting language&lt;/strong&gt; such as python or perl to do it for you (Highly recommended).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To make sure the value of &lt;strong&gt;numCookies&lt;/strong&gt; is overwritten, we can write 80 characters thanks to the following command:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boiteaklou@csb:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perl &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'print &quot;A&quot;x80'&lt;/span&gt; | ./cookiePublic64
Welcome to the Cookie Jar program!

In order to get the flag, you will need to have 100 cookies!

So, how many cookies are there &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the cookie jar:
Congrats, you have 1094795585 cookies!
Here&lt;span class=&quot;s1&quot;&gt;'s your flag: ----------REDACTED----------
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s working! Now, we just have to execute our exploit on the remote server in order to get the flag :blush:.&lt;/p&gt;

&lt;p&gt;I hope you now have a clearer idea of what is a buffer overflow. Do not hesitate to leave a comment or to contact me if you have any question or suggestion.&lt;/p&gt;

&lt;p&gt;BoiteAKlou :hammer:&lt;/p&gt;</content><author><name>BoiteAKlou</name></author><summary type="html">For my first article on this blog, I’ll present you my write-up of “CookieJar” from the AngstromCTF. This challenge was accessible and very straight-forward, which constitutes the prefect opportunity to introduce Buffer Overflows…</summary></entry></feed>